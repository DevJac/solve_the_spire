* Design
** Agents
*** CampfireAgent
**** States
- Player
- Cards in deck
- Relics
- Potions
- Map path
- Map boss
*** CombatAgent
**** States
- Player
- Player powers
- Monsters
- Monster powers
- Cards in hand
- Cards in draw
- Cards in discard
- Relics
- Potions
*** DeckAgent
**** States
- Cards in deck
- Relics
- Map boss
*** EventAgent
**** States
- Player
- Cards in deck
- Relics
- Potions
- Map paths
- Map boss
*** MapAgent
**** States
- Player
- Cards in deck
- Relics
- Potions
- Map paths
- Map boss
*** MenuAgent
*** PotionAgent
**** States
- Player
- Player powers
- Monsters
- Monster powers
- Cards in hand
- Cards in draw
- Cards in discard
- Relics
- Potions
*** RewardAgent
**** States
- Player
- Cards in deck
- Relics
- Potions
*** ShopAgent
**** States
- Player
- Cards in deck
- Relics
- Potions
*** SpecialActionAgent
Is this agent too broad?
**** States
- Player
- Player powers
- Monsters
- Monster powers
- Cards in deck
- Cards in hand
- Cards in draw
- Cards in discard
- Relics
- Potions
** Game states to consider
- Player
- Player powers
- Monsters
- Monster powers
- Cards in deck
- Cards in hand
- Cards in draw
- Cards in discard
- Relics
- Potions
- Map paths
- Map boss
** Encoders
- Player
- Monster
- Card
- Relic
- Potion
- Map
* Grid Actions
Upgrade, purge, transform, (draft)
Any number, fixed number
* Actions
** DamageAction
Game over
** DiscardAction
Discard one card from hand
** DiscoveryAction
Add one of three random cards to your hand
** GamblingChipAction
Discard any number of cards, then draw that many
** HandCheckAction
Unknown. Do we need to handle this? Appears to be rare.
** NightmareAction
Choose a card to copy
** RetainCardsAction
Cards to retain until next turn
** SetupAction
Put a card from your hand on top of your draw pile. It costs 0 until played.
* Refactor
- [ ] .
- [X] ├── agent.jl
- [ ] ├── notes.org
- [ ] ├── README.md
- [X] ├── relay.jl
- [ ] ├── src
- [X] │   ├── Encoders.jl
- [X] │   ├── Networks.jl
- [X] │   ├── SARSM.jl
- [X] │   ├── STSAgents.jl
- [X] │   ├── Utils.jl
- [ ] │   ├── agents
- [ ] │   │   ├── CampfireAgent.jl
- [X] │   │   ├── CombatAgent.jl
- [X] │   │   ├── DeckAgent.jl
- [ ] │   │   ├── EventAgent.jl
- [X] │   │   ├── MapAgent.jl
- [X] │   │   ├── MenuAgent.jl
- [ ] │   │   ├── PotionAgent.jl
- [ ] │   │   ├── RewardAgent.jl
- [ ] │   │   ├── ShopAgent.jl
- [ ] │   │   └── SpecialActionAgent.jl
- [X] └── test
- [X]     ├── Encoders.jl
- [X]     ├── Networks.jl
- [X]     ├── runtests.jl
- [X]     ├── SARSM.jl
- [X]     └── Utils.jl
* Available Commands
- "play"
- "end"
- "potion"
- "choose"
-
- "proceed"
- "return"
-
- "confirm"
- "leave"
- "skip"
-
- "key"
- "click"
- "start"
- "state"
- "wait"
- "cancel"
* Learning from JSON
Can we learn from JSON directly? I think I can encode the raw JSON.

Encode JSON paths (composed of object keys/attributes) into points in high dimensional space (like embeddings).
Encode array indexes as integer characters, but when feeding the recurrent neural network used for these path encodings, give it these integers as numerical values rather than one-hot encoded letters or whatever.

Maybe identify the words (object keys/attributes) that form the paths, and one-hot encode these words. Thus, we one-hot encode words instead of characters before feeding the RNN.

At this point we've encoded all paths to basic values into unordered points in high dimensional space.

The remaining values are strings, integers, and booleans. Integers and booleans are trivial to encode. Encode the remaining strings with, yet another, recurrent neural network.
